/**
 * @file ParticleSystem.hpp
 * @author wenyan4work (wenyan4work@gmail.com)
 * @brief System for particles
 * @version 1.0
 * @date 2018-12-13
 *
 * @copyright Copyright (c) 2018
 *
 */
#ifndef SYLINDERSYSTEM_HPP_
#define SYLINDERSYSTEM_HPP_

#include "Particle.hpp"
#include "ParticleConfig.hpp"
#include "ParticleNear.hpp"
#include "SharedParticleSurface.hpp"

#include "Boundary/Boundary.hpp"
#include "Constraint/ConstraintSolver.hpp"
#include "FDPS/particle_simulator.hpp"
#include "Trilinos/TpetraUtil.hpp"
#include "Trilinos/ZDD.hpp"
#include "Util/TRngPool.hpp"

#include <unordered_map>

/**
 * @brief A collection of particles distributed to multiple MPI ranks.
 *
 */
template <int spectralDegree>
class ParticleSystem {
    bool enableTimer = false;
    int snapID;                  ///< the current id of the snapshot file to be saved. sequentially numbered from 0
    int stepCount;               ///< timestep Count. sequentially numbered from 0
    unsigned int restartRngSeed; ///< parallel seed used by restarted simulations

    // FDPS stuff
    PS::DomainInfo dinfo; ///< domain size, boundary condition, and decomposition info
    void setDomainInfo();

    PS::ParticleSystem<Particle> particleContainer;        ///< particles
    SharedParticleSurface sharedPS;                     ///< shared particle surface (TODO: expand to support multiple particle types)
    std::unique_ptr<TreeParticleNear> treeParticleNearPtr; ///< short range interaction of particles
    int treeParticleNumber;                                ///< the current max_glb number of treeParticleNear
    void setTreeParticle();

    std::unordered_multimap<int, int> linkMap;        ///< links prev,next
    std::unordered_multimap<int, int> linkReverseMap; ///< links next, prev

    // Constraint stuff
    std::shared_ptr<ConstraintSolver> conSolverPtr;       ///< pointer to ConstraintSolver
    std::shared_ptr<ConstraintCollector> conCollectorPtr; ///<  pointer to ConstraintCollector
    Teuchos::RCP<const TV> forceUniRcp;                   ///< unilateral constraint force
    Teuchos::RCP<const TV> velocityUniRcp;                ///< unilateral constraint velocity
    Teuchos::RCP<const TV> forceBiRcp;                    ///< bilateral constraint force
    Teuchos::RCP<const TV> velocityBiRcp;                 ///< bilateral constraint velocity

    // computed without knowledge of constraints
    Teuchos::RCP<TV> forcePartNonBrownRcp;    ///< force specified by setForceNonBrown()
    Teuchos::RCP<TV> velocityPartNonBrownRcp; ///< velocity specified by setVelocityNonBrown()
    Teuchos::RCP<TV> velocityNonBrownRcp;     ///< \f$V_{NonBrown} = V_{part,NonBrown}+M F_{part,NonBrown}\f$
    Teuchos::RCP<TV> velocityBrownRcp;        ///< Brownian velocity, generated by calcBrown()
    Teuchos::RCP<TV> velocityNonConRcp;       ///< \f$V_{nc} = V_{Brown}+V_{NonBrown}\f$

    // MPI stuff
    std::shared_ptr<TRngPool> rngPoolPtr;      ///< TRngPool object for thread-safe random number generation
    Teuchos::RCP<const TCOMM> commRcp;         ///< TCOMM, set as a Teuchos::MpiComm object in constrctor
    Teuchos::RCP<TMAP> particleMapRcp;         ///< TMAP, contiguous and sequentially ordered 1 dof per particle
    Teuchos::RCP<TMAP> particleMobilityMapRcp; ///< TMAP, contiguous and sequentially ordered 6 dofs per particle
    Teuchos::RCP<TCMAT> mobilityMatrixRcp;     ///< block-diagonal mobility matrix
    Teuchos::RCP<TOP> mobilityOperatorRcp;     ///< full mobility operator (matrix-free), to be implemented

    // Data directory
    std::shared_ptr<ZDD<ParticleNearEP>> particleNearDataDirectoryPtr; ///< distributed data directory for particle data

    // internal utility functions
    /**
     * @brief generate initial configuration on rank 0 according to runConfig
     *
     */
    void setInitialFromConfig();

    /**
     * @brief set initial configuration as given in the (.dat) file
     *
     * The simBox and BC settings in runConfig are still used
     * @param filename
     */
    void setInitialFromFile(const std::string &filename);

    /**
     * @brief set linkMap from the .dat file
     *
     * Every mpi rank run this simultaneously to set linkMap from the same file
     * @param filename
     */
    void setLinkMapFromFile(const std::string &filename);

    /**
     * @brief set initial configuration as given in the (.dat) file
     *
     * The simBox and BC settings in runConfig are still used
     * @param pvtpFileName
     */
    void setInitialFromVTKFile(const std::string &pvtpFileName);

    /**
     * @brief set initial configuration if runConfig.initCircularX is set
     *
     * This function move the position of all particles into a cylindrical tube fit in initBox
     */
    void setInitialCircularCrossSection();

    /**
     * @brief display the configuration on rank 0
     *
     */
    void showOnScreenRank0();

    /**
     * @brief update the particleMap and particleMobilityMap
     *
     * This function is called in prepareStep(), and no adding/removing/exchanging is allowed before runStep()
     */
    void updateParticleMap(); ///< update particlemap and particleMobilityMap

    /**
     * @brief write VTK parallel XML file into baseFolder
     *
     * @param baseFolder
     */
    void writeVTK(const std::string &baseFolder);

    /**
     * @brief write Ascii file controlled by FDPS into baseFolder
     *
     * @param baseFolder
     */
    void writeAscii(const std::string &baseFolder);

    /**
     * @brief write a txt file containing timestep and most recent pvtp filenames info into baseFolder
     *
     * @param baseFolder
     */
    void writeTimeStepInfo(const std::string &baseFolder);

    /**
     * @brief write a simple legacy VTK file for simBox
     *
     */
    void writeBox();

    /**
     * @brief Get orientation quaternion with givne px,py,pz
     *
     * component in [px,py,pz] out of range [-1,1] will be randomly generated
     * if all out of range [-1,1], a uniformly random orientation on sphere is generated
     * @param orient
     * @param px
     * @param py
     * @param pz
     * @param threadId openmp thread id for random number generation
     */
    void getOrient(Equatn &orient, const double px, const double py, const double pz, const int threadId);

    /**
     * @brief update the rank data field of particle
     *
     */
    void updateParticleRank();

  public:
    ParticleConfig runConfig; ///< system configuration. Be careful if this is modified on the fly

    /**
     * @brief Construct a new ParticleSystem object
     *
     * initialize() should be called after this constructor
     */
    ParticleSystem() = default;

    /**
     * @brief Construct a new ParticleSystem object
     *
     * This constructor calls initialize() internally
     * @param configFile a yaml file for ParticleConfig
     * @param posFile initial configuration. use empty string ("") for no such file
     * @param argc command line argument
     * @param argv command line argument
     */
    ParticleSystem(const std::string &configFile, const std::string &posFile, int argc, char **argv);

    /**
     * @brief Construct a new ParticleSystem object
     *
     * This constructor calls initialize() internally
     * @param config ParticleConfig object
     * @param posFile initial configuration. use empty string ("") for no such file
     * @param argc command line argument
     * @param argv command line argument
     */
    ParticleSystem(const ParticleConfig &config, const std::string &posFile, int argc, char **argv);

    ~ParticleSystem() = default;

    // forbid copy
    ParticleSystem(const ParticleSystem &) = delete;
    ParticleSystem &operator=(const ParticleSystem &) = delete;

    /**
     * @brief initialize after an empty constructor
     *
     * @param config ParticleConfig object
     * @param posFile initial configuration. use empty string ("") for no such file
     * @param argc command line argument
     * @param argv command line argument
     */
    void initialize(const ParticleConfig &config, const std::string &posFile, int argc, char **argv);

    /**
     * @brief reinitialize from vtk files
     *
     * @param config ParticleConfig object
     * @param restartFile txt file containing timestep and most recent pvtp file names
     * @param argc command line argument
     * @param argv command line argument
     */
    void reinitialize(const ParticleConfig &config, const std::string &restartFile, int argc, char **argv,
                      bool eulerStep = true);

    /**
     * @brief enable the timer in step()
     *
     * @param value
     */
    void setTimer(bool value) { enableTimer = value; }

    /**
     * @brief compute axis-aligned bounding box of particles
     *
     * @param localLow
     * @param localHigh
     * @param globalLow
     * @param globalHigh
     */
    void calcBoundingBox(double localLow[3], double localHigh[3], double globalLow[3], double globalHigh[3]);

    /**
     * @brief compute domain decomposition by sampling particle distribution
     *
     * domain decomposition must be triggered when particle distribution significantly changes
     */
    void decomposeDomain();

    /**
     * @brief exchange between mpi ranks according to domain decomposition
     *
     * particle exchange must be triggered every timestep:
     */
    void exchangeParticle();

    /**
     * one-step high level API
     */
    // get information
    /**
     * @brief Get particleContainer
     *
     * @return PS::ParticleSystem<Particle>&
     */
    const PS::ParticleSystem<Particle> &getContainer() { return particleContainer; }
    PS::ParticleSystem<Particle> &getContainerNonConst() { return particleContainer; }

    /**
     * @brief Get the DomainInfo object
     *
     * @return PS::DomainInfo&
     */
    const PS::DomainInfo &getDomainInfo() { return dinfo; }
    PS::DomainInfo &getDomainInfoNonConst() { return dinfo; }

    const std::unordered_multimap<int, int> &getLinkMap() { return linkMap; }
    const std::unordered_multimap<int, int> &getLinkReverseMap() { return linkReverseMap; }

    /**
     * @brief Get the RngPoolPtr object
     *
     * @return std::shared_ptr<TRngPool>&
     */
    std::shared_ptr<TRngPool> &getRngPoolPtr() { return rngPoolPtr; }

    /**
     * @brief Get the CommRcp object
     *
     * @return Teuchos::RCP<const TCOMM>&
     */
    Teuchos::RCP<const TCOMM> &getCommRcp() { return commRcp; }

    /**
     * @brief prepare a step
     *
     * apply simBox boundary condition
     * decomposeDomain() for every 50 steps
     * exchangeParticle() at every step
     * clear velocity
     * rebuild map
     * compute mobility matrix&operator
     * between prepareStep() and runStep(), particles should not be moved, added, or removed
     */
    void prepareStep();

    /**
     * @brief Set the (optional) forceNonBrownRcp
     *
     * This is optional.
     * this force is added to forceNonB
     * The computed mobility matrix will be applied to this force and the result is added to velNonB
     * @param forceNonBrown
     */
    void setForceNonBrown(const std::vector<double> &forceNonBrown);

    /**
     * @brief Set the (optional) velocityNonBrownRcp
     *
     * This is optional. The result is added to velNonB
     * @param velNonBrown
     */
    void setVelocityNonBrown(const std::vector<double> &velNonBrown);

    ConstraintBlockPool &getConstraintPoolNonConst() { return *(conCollectorPtr->constraintPoolPtr); };

    /**
     * @brief resolve collision with given nonBrownian motion and advance the system configuration
     *
     */
    void runStep();

    // These should run after runStep()
    /**
     * @brief add new Particles into the system from all ranks
     *
     * add new particles
     * 1. new gids will be randomly generated and assigned to each new particle
     * 2. added new particles will be appended to the local rank
     *
     * @param newParticle list of new particles.
     * @return the generated new gids of the added new particles
     */
    std::vector<int> addNewParticle(const std::vector<Particle> &newParticle);

    /**
     * @brief add new links into the system from all ranks
     *
     * the newLink will be gathered from all ranks, remove duplication, and synchronized to the linkMap on all ranks
     *
     * @param newLink
     */
    void addNewLink(const std::vector<Link> &newLink);

    /**
     * @brief calculate both Col and Bi stress
     *
     */
    void calcConStress();

    /**
     * @brief calculate polar and nematic order parameter
     *
     * The result is shown on screen
     */
    void calcOrderParameter();

    /**
     * @brief calculate volume fraction
     *
     */
    void calcVolFrac();

    /**
     * detailed low level API
     */
    /**
     * @brief apply periodic boundary condition
     *
     */
    void applyBoxBC();

    // compute non-collision velocity and mobility, before collision resolution
    /**
     * @brief calculate translational and rotational Brownian motion as specified in runConfig
     *
     * write back to particle.velBrown/omegaBrown
     */
    void calcVelocityBrown();

    /**
     * @brief calculate translational and rotational hydrodynamic motion as specified in runConfig
     *
     * write back to particle.velHydro/omegaHydro
     */
    void calcVelocityHydro();

    /**
     * @brief calculate known velocity before collision resolution
     *
     * velocityNonCon = velocityBrown + velocityNonBrown + mobility * forceNonBrown
     * velocityNonBrown sums both the values set by setVelocityNonBrown() and directly written to
     * particle[i].velNonB/omegaNonB
     * write back to particle.velNonB/omegaNonB
     */
    void calcVelocityNonCon();

    /**
     * @brief sum vel = velNonB + velB + velCol + velBi
     *
     */
    void sumForceVelocity();

    /**
     * @brief calculate the mobility matrix (block diagonal)
     *
     */
    void calcMobMatrix();

    /**
     * @brief calculate the mobility operator (full-dense, matrix-free)
     *
     * TODO: to be implemented
     */
    void calcMobOperator();

    /**
     * @brief build the ZDD<ParticleNearEP> object
     *
     */
    void buildParticleNearDataDirectory();

    /**
     * @brief Get the ParticleNearDataDirectory object
     *
     * @return std::shared_ptr<const ZDD<ParticleNearEP>>&
     */
    std::shared_ptr<ZDD<ParticleNearEP>> &getParticleNearDataDirectory() { return particleNearDataDirectoryPtr; }

    // resolve constraints
    void collectPairCollision();     ///< collect pair collision constraints
    void collectBoundaryCollision(); ///< collect boundary collision constraints
    void collectLinkBilateral();     ///< setup link constraints

    void resolveConstraints();           ///< resolve constraints
    void saveForceVelocityConstraints(); ///< write back to particle.velCol and velBi

    void stepEuler(); ///< Euler step update position and orientation, with both collision and non-collision velocity

    // write results
    std::string getCurrentResultFolder();          ///< get the current output folder path
    std::string getResultFolderWithID(int snapID); ///< get output folder path with snapID
    bool getIfWriteResultCurrentStep();            ///< check if the current step is writing (set by runConfig)
    int getSnapID() { return snapID; };            ///< get the (sequentially ordered) ID of current snapshot
    int getStepCount() { return stepCount; };      ///< get the (sequentially ordered) count of steps executed
    void writeResult();                            ///< write result regardless of runConfig

    // expose raw vectors and operators
    // non-constraint parts
    Teuchos::RCP<TV> getForcePartNonBrown() const { return forcePartNonBrownRcp; }
    Teuchos::RCP<TV> getVelocityPartNonBrown() const { return velocityPartNonBrownRcp; };
    Teuchos::RCP<TV> getVelocityNonBrown() const { return velocityNonBrownRcp; };
    Teuchos::RCP<TV> getVelocityBrown() const { return velocityBrownRcp; };
    Teuchos::RCP<TV> getVelocityNonCon() const { return velocityNonConRcp; };

    // constraint parts
    Teuchos::RCP<const TV> getForceUni() const { return forceUniRcp; };
    Teuchos::RCP<const TV> getVelocityUni() const { return velocityUniRcp; };
    Teuchos::RCP<const TV> getForceBi() const { return forceBiRcp; };
    Teuchos::RCP<const TV> getVelocityBi() const { return velocityBiRcp; };

    // mobility
    Teuchos::RCP<TCMAT> getMobMatrix() { return mobilityMatrixRcp; };
    Teuchos::RCP<TOP> getMobOperator() { return mobilityOperatorRcp; };

    // get information
    /**
     * @brief Get the local and global max gid for particles
     *
     * @return std::pair<int, int> [localMaxGid,globalMaxGid]
     */
    std::pair<int, int> getMaxGid();

    /**
     * @brief
     *
     * @param zeroOut zero out all timing info after printing out
     */
    void printTimingSummary(const bool zeroOut = true);
};

// Include the ParticleSystem implimentation
#include "ParticleSystem.tpp"
#endif